## 6.3 다이내믹 프록시와 팩토리 빈

### 6.3.1 프록시와 프록시 패턴, 데코레이터 패턴

트랜잭션 경계설정 코드를 비즈니스 로직 코드에서 분리해낼 때 적용했던 기법을 다시 검토해보자.

단순히 확장성을 고려해서 한 가지 기능을 분리한다면 전형적인 전략패턴을 사용하면 된다. 트랜잭션 기능에는 추상화 작업을 통해 이미 전략 패턴이 적용되어 있다. 하지만 전략 패턴으로는 트랜잭션 기능의 구현 내용을 분리해냈을 뿐이다. 트랜잭션을 적용해야 한다는 사실은 코드에 그대로 남아 있다. 아래 그림은 트랜잭션과 같은 부가적인 기능을 위임을 통해 외부로 분리했을 때의 결과를 보여준다. 구체적인 구현 코드는 제거했을지라도 위임을 통해 기능을 사용하는 코드는 핵심 코드와 함께 남아있다.

<img width="698" alt="image" src="https://github.com/pak0426/pak0426/assets/59166263/4462748a-dc3b-4c8a-9f9d-624a1200af6a">

**트랜잭션이라는 기능은 사용자 관리 비즈니스 로직과 성격이 다르기 때문에 아예 그 적용 사실 자체를 밖으로 분리할 수 있다.** 아래 그림과 같이 부가기능 전부를 핵심 코드가 담긴 클래스에서 독립시킬 수 있다. 이 방법을 이용해 UserServiceTx 를 만들었고, UserServiceImpl 에는 트랜잭션 관련 코드가 하나도 남지 않게 됐다.

<img width="672" alt="image" src="https://github.com/pak0426/pak0426/assets/59166263/5a5c4465-abf7-4084-a326-a5d1106342aa">

이렇게 분리된 부가기능을 담은 클래스는 중요한 특징이 있다. 부가기능 외의 나머지 모든 기능은 원래 핵심기능을 가진 클래스로 위임해줘야 한다. 핵심기능은 부가기능을 가진 클래스의 존재 자체를 모른다. 따라서 부가기능이 핵심기능을 사용하는 구조가 되는 것이다.  
문제는 이렇게 구성했더라도 클라이언트가 핵심기능을 가진 클래스를 직접 사용해버리면 부가기능이 적용될 기회가 없다는 점이다. 그래서 부가기능은 마치 자신이 핵심기능을 가진 클래스인 것처럼 꾸며서, 클라이언트가 자신을 거쳐서 핵심기능을 사용하도록 만들어야 한다. 그러기 위해서는 클라이언트는 인터페이스를 통해서만 핵심기능을 사용하게 하고, 부가기능 자신도 같은 인터페이스를 구현한 뒤에 자신이 그 사이에 끼어들어야 한다. 그러면 클라이언트는 인터페이스만 보고 사용을 하기 때문에 자신은 핵심기능을 가진 클래스를 사용할 것이라고 기대하지만, 사실은 아래 그림처럼 부가기능을 통해 핵심기능을 이용하게 되는 것이다.

<img width="707" alt="image" src="https://github.com/pak0426/pak0426/assets/59166263/db1d1cb3-9acc-4db1-93bd-60a972d88ba6">

부가기능 코드에서는 핵심기능으로 요청을 위임해주는 과정에서 자신이 가진 부가적인 기능을 적용해줄 수 있다. 비즈니스 로직 코드에 트랜잭션 기능을 부여해주는 것이 바로 그런 대표적인 경우다.  
이렇게 마치 자신이 클라이언트가 사용하려고 하는 실제 대상인 것처럼 위장해서 클라이언트의 요청을 받아주는 것을 대리자, 대리인과 같은 역할을 한다고 해서 **프록시**라고 부른다. 그리고 프록시를 통해 최종적으로 요청을 위임받아 처리하는 실제 오브젝트를 **타깃** 또는 **실체**라고 부른다. 아래 그림은 클라이언트가 프록시를 통해 타깃을 사용하는 구조를 보여주고 있다.

<img width="714" alt="image" src="https://github.com/pak0426/pak0426/assets/59166263/8cdb6e3d-c1ad-481b-b3e8-da046c378118">

프록시의 특징은 타깃과 같은 인터페이스를 구현했다는 것과 프록시가 타깃을 제어할 수 있는 위치에 있다는 것이다.  
프록시는 사용 목적에 따라 2가지로 구분할 수 있다.

1. 클라이언트가 타깃에 접근하는 방법을 제어하기 위해서
2. 타깃에 부가적인 기능을 부여해주기 위해서

**두 가지 모두 대리 오브젝트라는 개념의 프록시를 두고 사용하는 점을 동일하지만, 목적에 따라서 디자인 패턴에서는 다른 패턴으로 구분한다.**

### 데코레이터 패턴

데코레이터 패턴은 타깃에 **부가적인 기능을 런타임 시 다이내믹하게 부여해주기 위해 프록시를 사용하는 패턴**을 말한다. 다이내믹하게 기능을 부가한다는 의미는 컴파일 시점, 즉 코드상에서는 어떤 방법과 순서로 프록시와 타깃이 연결되어 사용되는지 정해져 있지 않다는 뜻이다. 이 패턴의 이름이 데코레이터라고 불리는 이유는 마치 제품이나 케익 등을 여러 겹으로 포장하고 그 위에 장식을 붙이는 것처럼 실제 내용물은 동일하지만 부가적인 효과를 부여해줄 수 있기 때문이다. 따라서 데코레이터 패턴에서는 프록시가 꼭 한 개로 제한되지 않는다. 프록시가 직접 타깃을 사용하도록 고정시킬 필요도 없다. 이를 위해 데코레이터 패턴에서는 같은 인터페이스를 구현한 타켓과 여러 개의 프록시를 사용할 수 있다. 프록시가 여러 개인 만큼 순서를 정해서 단계적으로 위임하는 구조로 만들면 된다.

예를 들어 소스코드를 출력하는 기능을 가진 핵심기능이 있다고 생각해보자. 이 클래스에 데코레이터 개념을 부여해서 타깃과 같은 인터페이스를 구현하는 프록시를 만들 수 있다. 예를 들어 소스코드에 라인넘버를 붙여준다거나, 문법에 따라 색을 변경해주거나, 특정 폭으로 소스를 잘라주거나, 페이지를 표시해주는 등의 부가적인 기능을 프록시로 만들어두고 아래 그림과 같이 런타임 시에 이를 적절한 순서로 조합해서 사용하면 된다.

<img width="720" alt="image" src="https://github.com/pak0426/pak0426/assets/59166263/4d93fc43-c971-4eb0-a4ea-260b78d16f1f">

프록시로서 동작하는 각 데코레이터는 위임하는 대상에도 인터페이스로 접근하기 때문에 자신이 최종 타깃으로 위임하는지, 아니면 다음 단계의 데코레이터 프록시로 위임하는지 알지 못한다. 그래서 데코레이터의 다음 위임 대상은 인터페이스로 선언하고 생성자나 수정자 메서드를 통해 위임 대상을 외부에서 런타임 시에 주입받을 수 있도록 만들어야 한다.

자바 IO 패키지의 InputStream 과 OutputStream 구현 클래스는 데코레이터 패턴이 사용된 대표적인 예다. 다음 코드는 InputStream 이라는 인터페이스를 구현한 타깃인 FileInputStream 에 버퍼 읽기 기능을 제공해주는 BufferedInputStream 이라는 데코레이터를 적용한 예다.

```java
InputStream is = new BufferedInputStream(new FileInputStream("a.txt"));
```

UserService 인터페이스를 구현한 타깃인 UserServiceImpl에 트랜잭션 부가기능을 제공해주는 UserServiceTx 를 추가한 것도 데코레이터 패턴을 적용한 것이라고 볼 수 있다. 이 경우는 수정자 메서드를 통해 데코레이터인 UserServiceTx 에 위임할 타깃인 UserServiceImpl 을 주입해줬다.  
인터페이스를 통한 데코레이터 정의와 런타임 시의 다이내믹한 구성 방법은 스프링의 DI를 이용하면 아주 편리하다. 데코레이터 빈의 프로퍼티 같은 인터페이스를 구현한 다른 데코레이터 또는 타깃 빈을 설정하면 된다.  
스프링의 설정을 다시 살펴보자. UserServiceTx 클래스로 선언된 userService 빈은 데코레이터다. UserServiceTx 는 UserService 타입의 오브젝트를 DI 받아서 기능은 위임하지만, 그 과정에서 트랜잭션 경계설정 기능을 부여해준다. 아래 리스트에 나타난 대로 현재는 UserServiceImpl 클래스로 선언된 타깃 빈이 DI 를 통해 데코레이터인 userService 빈에 주입되도록 설정되어 있다. 다이내믹한 부가기능의 부여라는 데코레이터 패턴의 전형적인 적용 예다.

<img width="590" alt="image" src="https://github.com/pak0426/pak0426/assets/59166263/d078c6b3-2d56-4633-96da-ca8c9883b9f0">

데코레이터 패턴은 **인터페이스를 통해 위임하는 방식이기 때문에 어느 데코레이터에서 타깃으로 연결될지 코드 레벨에선 미리 알 수 없다.** 구성하기에 따라서 여러 개의 데코레이터를 적용할 수도 있다. UserServiceTx 도 UserService 라는 인터페이스를 통해 다음 오브젝트로 위임하도록 되어 있지만 UserServiceImpl 이라는 특정 클래스로 위임하도록 되어 있지 않다.  
데코레이터 패턴은 타깃의 코드에 손대지 않고, 클라이언트가 호출하는 방법도 변경하지 않은 채로 새로운 기능을 추가할 때 유용한 방법이다.

#### 프록시 패턴

일반적으로 사용하는 프록시라는 용어와 디자인 패턴에서 말하는 프록시 패턴은 구분할 필요가 있다.

1. 전자는 클라이언트와 사용 대상 사이에 대리 역할을 맡은 오브젝트를 두는 방법
2. 후자는 프록시를 사용하는 방법 중에서 타깃에 대한 접근 방법을 제어하려는 목적을 가진 경우

프록시 패턴의 프록시는 타깃의 기능을 확장, 추가하지 않는다. 대신 클라이언트가 타깃에 접근하는 방식을 변경해준다. 타깃 오브젝트를 생성하기가 복잡하거나 당장 필요하지 않은 경우에는 꼭 필요한 시점까지 오브젝트를 생성하지 않는 편이 좋다. 그런데 타깃 오브젝트에 대한 레퍼런스가 미리 필요할 수 있다. 이럴 때 프록시 패턴을 적용하면 된다. **클라이언트에게 타깃에 대한 레퍼런스를 넘겨야 하는데, 실제 타깃 오브젝트는 만드는 대신 프록시를 넘겨주는 것이다.** 그리고 프록시의 메서드를 통해 타깃을 사용하려고 시도하면, 그때 **프록시가 타깃 오브젝트를 생성하고 요청을 위임해주는 식이다.**  
만약 레퍼런스를 가지고 있어도 프록시를 통해 생성을 최대한 늦춤으로써 얻는 장점이 많다.  
또는 원격 오브젝트를 이용할때 RMI나 EJB 똔느 각종 리모팅 기술을 이용해 다른 서버에 존재하는 오브젝트를 사용해야 한다면 원격 오브젝트에 대한 프록시를 만들고, 클라이언트는 마치 로컬에서 사용하는 것처럼 프록시를 사용할 수 있다. (프록시는 클라이언트 요청 발생 시 네트워크를 통해 원격 오브젝트를 실행 후 결과를 받아 돌려준다.)

이렇게 프록시 패턴은 타깃의 기능 자체에는 관여하지 않으면서 젖ㅂ근하는 방법을 제어해주는 프록시를 이용하는 것이다. 구조적으로 보자면 프록시와 데코레이터는 유사하다. 다만 프록시는 코드에서 자신이 만들거나 접근할 타깃 클래스 정보를 알고 있는 경우가 많다. 생성을 지연하는 프록시라면 구체적인 생성 방법을 알아야 하기 때문에 타깃 클래스에 대해 직접적인 정보를 알아야 한다. 물론 프록시 패턴이라고 하더라도 인터페이스를 통해 위임하도록 만들 수도 있다. 인터페이스를 통해 다음 호출 대상으로 접근하게 하면 그 사이에 다른 프록시나 데코레이터가 추가도리 수 있기 때문이다. 아래 그림은 접근 제어를 위한 프록시를 두는 프록시 패턴과 컬러, 페이징 기능을 추가하기 위한 프록시를 두는 데코레이터 패턴을 함께 적용한 예다.

<img width="708" alt="image" src="https://github.com/pak0426/pak0426/assets/59166263/bea6be3a-b967-4aeb-9efb-aea41132df8f">

앞으로는 타깃과 동일한 인터페이스를 구현하고 클라이언트와 타깃 사이에 존재하면서 기능의 부가 또는 접근 제어를 담당하는 오브젝트를 모두 프록시라고 부르겠다.