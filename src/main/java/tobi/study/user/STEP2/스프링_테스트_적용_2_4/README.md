# 2.4 스프링 테스트 적용

이제 테스트 코드도 어느 정도 깔끔하게 정리했다. 하지만 아직 한 가지 찜찜한 부분이, 바로 애플리케이션 컨텍스트 생성 방식이다. @BeforeEach 메서드가 테스트 메서드 개수만큼 반복되기 때문에 애플리케이션 컨텍스드도 세 번 만들어진다. 지금은 설정도 간단하고 별 문제 아닌 듯하지만, 

빈이 많아지고 복잡해지면 애플리케이션 컨텍스트 생성에 적지 않은 시간이 걸릴 수 있다. 애플리케이션 컨텍스트가 만들어질 때는 모든 싱글톤 빈 오브젝트를 초기화한다. 단순히 빈 오브젝트를 만드는 정도라면 괜찮지만, 어떤 빈은 오브젝트가 생성될 때 자체적인 초기화 작업을 진행해서 제법 많은 시간을 필요로 하기 때문이다. 또 한가지 문제는 애플리케이션 컨텍스트가 초기화될 때 어떤 빈은 독자적으로 많은 리소스를 할당하거나 독립적으로 스레드를 띄우기도 한다는 점이다. 이런 경우에는 테스트를 마칠 때마다 애플리케이션 컨텍스트내의 빈이 할당한 리소스 등을 깔끔하게 정리해주지 않으면 다음 테스트에서 새로운 애플리케이션 컨텍스트가 만들어지면서 문제를 일으킬 수도 있다.

### 스프링 테스트 컨텍스트 프레임워크 적용

<img width="621" alt="image" src="https://github.com/pak0426/pak0426/assets/59166263/9f383eaf-6ade-47f3-a576-a46169c42c78">

코드를 위와 같이 수정하고 실행하면 성공할 것이다.

그런데 인스턴스 변수인 context는 어디에서도 초기화해주는 코드가 없다. 따라서 setUp() 메서드에서 context를 사용하려고 하면 NullPointException이 발생한다. 하지만 위 코드는 문제가 없다. context 변수에 애플리케이션 컨텍스트가 들어 있기 때문이다. 스프링 컨텍스트 프레임워크의 JUnit 확장기능이 야간 마법을 부리는 것이다.


### 테스트 메서드의 컨텍스트 공유

<img width="619" alt="image" src="https://github.com/pak0426/pak0426/assets/59166263/33f53bb5-0c36-4ec8-bcf7-ff62781b2786">

위 코드를 출력하면

<img width="485" alt="image" src="https://github.com/pak0426/pak0426/assets/59166263/dc7d822e-fffd-4aa6-b23c-5bba41d37e7a">

context와 this의 오브젝트 값을 살펴보면, 동일한 context 임을 확인할 수 있다. 따라서 하나의 애플리케이션 컨텍스트가 만들어져 모든 테스트 메서드에서 사용되고 있음을 알 수 있다. 반면 UserDaoTest의 오브젝트는 매번 주소 값이 다르다. 앞에 설명한 거처럼 테스트 오브젝트를 새롭게 만들기 떄문이다.

### 테스트 클래스의 컨텍스트 공유

스프링 테스트 컨텍스트 프레임워크의 기능은 하나의 테스트 클래스 안에서 애플리케이션 컨텍스트를 공유해주는 것이 전부가 아니다. 여러 개의 테스트 클래스가 있는데 모두 같은 설정 파일을 가진 애플리케이션 컨텍스트를 사용한다면, 스프링은 애플리케이션 컨텍스트를 공유하게 해준다.

<img width="558" alt="image" src="https://github.com/pak0426/pak0426/assets/59166263/8d17e650-1055-4dde-8937-ff8e0c4a2303">

따라서 수백 개의 테스트 클래스를 만들었는데도 모두 같은 설정파일을 사용한다고 해도 테스트 전체에 걸쳐 단 한 개의 애플리케이션 컨텍스트만 만들어져 사용된다. 이 덕분에 테스트 성능이 향상된다.

### @Autowired

@Autowireds는 스프링 DI에 사용되는 특별한 애노테이션이다. 
@Autowired가 붙은 인스턴스 변수가 있으면, 

1. 테스트 컨텍스트 프레임워크는 변수 타입과 일치하는 컨텍스트 내의 빈을 찾는다.
2. 타입이 일치하는 빈이 있으면 인스턴스 변수에 주입해준다.

일반적으로 주입을 위해서는 생성자나 수정자 메서드가 필요한데 이 경우에는 메서드가 없어도 가능하다. 또 별도의 DI 설정 없이 필드의 타입정보를 이용해 빈을 자동으로 갖올 수 있는데, 이런 방법을 타입에 의한 자동 와이어링이라고 한다.

하지만 이상한 점은 앞서 만든 테스트 코드는 xml 파일에 정의된 빈이 아니라, ApplicationContext라는 타입의 변수에 @Autowired를 붙였는데도 DI가 됐다. 스프링 애플리케이션 컨텍스트는 초기화할 때 자기 자신도 빈으로 등록한다. 따라서 애플리케이션 컨텍스트에는 ApplicationContext 타입의 빈이 존재하는 셈이고 DI도 가능한 것이다.

@Autowired 를 이용해 DI를 받을 수 이다면 굳이 컨텍스트를 가져와 getBean() 하는게 아니라 직접 DI를 받을 수 있을 것이다.

<img width="601" alt="image" src="https://github.com/pak0426/pak0426/assets/59166263/5ec70a33-a666-4914-8d14-21bb73973017">

@Autowired를 지정만 하면 어떤 빈이든 다 가져올 수 있다. XML에 dataSource라는 이름으로 등록한 SimpleDriverDataSource 클래스 타입은 물론이고, 인터페이스인 DataSource 타입으로 변수를 선언해도 된다.

```java
@Autowired
SimpleDriverDataSource dataSource;
```
```java
@Autowired 
DataSource dataSource;
```

그렇다면 SimpleDriverDataSource 타입의 변수로 선언하는 방법과 DataSource 타입으로 선언하는 방법 중 어떤 것이 나을까? 그건 테스트에서 빈을 어떤 용도로 사용하느냐에 따라 다르다.

단순히 DataSource에 정의된 메스드를 테스트하고 싶으면 DataSource를 사용해도 좋다. DataSource로 선언해두면 dataSource 빈의 구현 클래스를 변경하더라도 테스트 코드를 수정할 필요가 없다.

반면에 테스트에서 SimpleDriverDataSource라는 타입의 오브젝트에 관심이 있는 경우가 있을 수도 있다.
이때는 SimpleDriverDataSource 타입으로 선언해야 한다. 예를 들어 XML에 속성으로 선언한 DB 연결정보를 확인하고 싶거나 SimpleDriverDataSource 클래스의 메서드를 직접 이용해야 한다면 사용하면 된다.

하지만 꼭 필요하지 않다면 테스트에서도 가능한 한 인터페이스를 사용해서 애플리케이션 코드와 느슨하게 연결해두는 편이 좋다.