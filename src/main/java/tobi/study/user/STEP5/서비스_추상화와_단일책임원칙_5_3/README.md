## 5.3 서비스 추상화와 단일 책임 원칙

#### 수직, 수평 계층구조와 의존관계

추상화 기법을 이용하면 특정 기술환경에 종속되지 않는 유연한 코드를 만들 수 있다. 

-> 코드의 기능적인 관심에 따라 분리되고, 서로 불필요한 영향을 주지 않으면서 독자적으로 확장이 가능하다.

트랜잭션 추상화는 애플리케이션 비즈니스 로직과 그 하위에서 동작하는 로우레벨의 트랜잭션 기술이라는 아예 다른 계층의 특성을 갖는 코드를 분리한 것이다.

<img width="531" alt="image" src="https://github.com/pak0426/pak0426/assets/59166263/2bac537f-917e-427b-82ee-fc6543793285">

위 그림은 지금까지 만든 사용자 관리 모듈의 의존관계를 나타낸다.

애플리케이션 로직의 종류에 따른 수평적 구분이든, 로직과 기술이라는 수직적인 구분이든 모두 결합도가 낮으며, 서로 영향을 주지 않고 자유롭게 확장할 수 있는 구조를 만들 수 있는데는 스프링 DI가 중요한 역할을 하고 있다. DI의 가치는 이렇게 관심, 책임, 성격이 다른 코드를 깔끔하게 분리하는 데 있다.

#### 단일 책임 원칙

이러한 적절한 분리가 가져오는 특징은 객체지향 설계의 원칙 중의 하나인 **단일 책임 원칙**으로 설명할 수 있다. 단일 책임 원칙은 하나의 모듈은 한 가지 책임을 가져야 한다는 의미다. 하나의 모듈이 바뀌는 이유는 한 가지여야 한다고 설명할 수도 있다.

#### 단일 책임 원칙의 장점

어떤 변경이 필요할 때 수정 대상이 명확해진다. 기술이 바뀌면 기술 계층과의 연동을 담당하는 기술 추상화 계층의 설정만 바꿔주면 된다. 비즈니스 로직도 마찬가지다. 단일 책임원칙을 지키지 않는다면 만약 DAO 를 수백 군데에서 사용한다면 수 백개의 클래스와 테스트 코드 전부 수정해줘야 한다. 그런 경우와 DI를 해주는 설정 파일 몇 줄 수정해주는 방식과 비교하면 차이가 정말 크다.

그래서 적절하게 책임과 관심이 다른 코드를 분리하고, 서로 영향을 주지 않도록 다양한 추상화 기법을 도입하는 것이 필요하다. 이를 위한 핵심적인 도구가 바로 스프링이 제공하는 DI다. 스프링의 DI가 없었다면 인터에시를 도입해서 나름 추상화를 했더라도 적지 않은 코드 사이의 결합이 남아 있게 된다.

클래스에서 new 생성자를 통해 직접 의존 클래스 정보가 드러나는 코드를 생각해보자. 이런 식이라면 인터페이스로 추상화를 안했을 때보다 낫긴하지만 의존 클래스를 변경할때마다 비즈니스 로직을 담은 코드의 수정이 발생한다. **결국 DI를 통해 의존 클래스의 생성과 의존 관계 설정을 스프링에 맡긴 덕에 완벽하게 트랜잭션 기술에서 자유로운 비즈니스 클래스를 가질 수 있게 된다.**  

객체지향 설계와 프로그래밍 원칙은 긴밀하게 관련이 있다. 단일 책임 원칙을 잘 지키는 코드를 만들려면 인터페이스를 도입하고 이를 DI로 연결해야 하며, 그 결과로 단일 책임 원칙뿐 아니라 개방 폐쇄 원칙도 잘 지키고, 모듈 간에 결합도가 낮아서 서로의 변경이 영향을 주지 않고, 같은 이유로 변경이 단일 책임에 집중되는 응집도 높은 코드가 나오니까 말이다. 이런 과정에서 전략 패턴, 어댑터 패턴, 브리지 패턴, 미디에이터 패턴 등 많은 디자인 패턴이 자연스럽게 적용되기도 한다.

객체지향 설계 원칙을 잘 지켜서 만든 코드는 테스트하기도 편하다. 스프링이 지원하는 DI와 싱글톤 레지스트리 덕분에 더욱 편리하게 자동화된 테스트를 만들 수 있다.